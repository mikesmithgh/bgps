#!/usr/bin/env bash
#
# Copyright (C) 2017 Michael Smith <mjsmith1028@gmail.com>
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# A better bash prompt for git. bgps provides a convenient way to customize
# the PS1 prompt and to determine information about the current git branch.
# bgps can indicate if the branch has a clean or dirty working tree, whether
# or not it is tracking a remote branch, and the number of commits the local
# branch is ahead or behind the remote branch.
#
# Parts of this program were copied and modified from
# <https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh>
#

# Function Definitions ########################################################

#######################################
# Read contents of file to variables
# Arguments:
#   $filepath the path of the file to read
#   $variable_names... the name of the variables to store the contents
#######################################
_eread ()
{
  local filepath="${1}"
  shift
  [[ -r "${filepath}" ]] && read -r "$@" <"${filepath}"
}

#######################################
# Print error message to stderr
# Arguments: $error_message
#######################################
_err() {
  printf -- "bgps: %s" "${1}" >&2
}

#######################################
# Check if file exists and if file is a regular file
# Arguments: $filepath the path of the file to check
# Returns: 0 on success
#######################################
_file_exists() {
  local return_code=0
  local filepath="${1}"
  if [[ ! -e "${filepath}" ]]; then
    _err "cannot access '${filepath}': No such file"
    return_code=1
  elif [[ ! -f "${filepath}" ]]; then
    _err "cannot access '${filepath}': Not a regular file"
    return_code=1
  fi
  return ${return_code}
}

#######################################
# Remove first and last double quotes from string, if they exist
# Arguments: $no_quote the string to remove quotes from
#######################################
_remove_quotes() {
  local no_quote="${1%\"}"
  printf -- "%s" "${no_quote#\"}"
}

#######################################
# Add configuration to config map
# Globals: $BGPS_CONFIG
# Arguments:
#   $key the config map key
#   $value the config map value
#######################################
_set_config_value() {
  IFS=" " read -r -a valid_config_keys <<< "$(_bgps_config_keys)"
  local key="${1^^}"
  local value="${2}"
  for valid_key in "${valid_config_keys[@]}" ; do
    if [[ "${key}" == "${valid_key}" ]] ; then
      # add to config map
      BGPS_CONFIG["${key}"]=$(_remove_quotes "${value}")
    fi
  done
}

#######################################
# Get configuration from config map.
# If a default value is provided and there is no value in the config, then
# return the default value
# Globals: $BGPS_CONFIG
# Arguments:
#   $key the config map key
#   $default_value the default value if there is no value in the config
#######################################
_get_config_value() {
  local key="${1^^}"
  local default_value="${2}"
  local value="${BGPS_CONFIG[${key}]}"
  [[ -z "${value}" ]] && printf -- "%s" "${default_value}" || printf -- "%s" "${value}"
}

#######################################
# Clear all configuration in the config map
# Globals: $BGPS_CONFIG
#######################################
_clear_config_values() {
  local keys=("${!BGPS_CONFIG[@]}")
  for key in "${keys[@]}"; do
    unset "BGPS_CONFIG[$key]"
  done
}

#######################################
# Read file and store in global config map
# Globals: $BGPS_CONFIG
# Arguments: $config_file the configuration filepath
#######################################
_read_config() {
  local config_file="${1}"
  if _file_exists "${config_file}" ; then
    while IFS=$'=\r\n' read -r key value; do
      _set_config_value "${key}" "${value}"
    done < "${config_file}"
  fi
}

#######################################
# Set the config map by reading the values from the provided file.
# Only read from file if md5sum is different, otherwise hit the cache.
# Globals:
#   $BGPS_CONFIG
#   $BGPS_GLOBAL_CONFIG
#   $BGPS_USER_CONFIG
#   $BGPS_CHECKSUM
# Arguments: $config_file the configuration filepath
# Returns: 0 on success
#######################################
_set_config() {
  local return_code=0
  local hash_code=""
  local configs=()
  if [[ -n "${1}" ]] ; then
    local param_config="${1}"
    if _file_exists "${param_config}" ; then
      configs+=("${param_config}")
    else
      return_code=1
    fi
  else
    _file_exists "${BGPS_GLOBAL_CONFIG}" 2>/dev/null && configs+=("${BGPS_GLOBAL_CONFIG}")
    _file_exists "${BGPS_USER_CONFIG}" 2>/dev/null && configs+=("${BGPS_USER_CONFIG}")
    if (( ! "${#configs[@]}" )) ; then
      # default config file does not exist so lets print a shrug face
      BGPS_CHECKSUM="¯\_(ツ)_/¯"
      _clear_config_values
      _set_config_value "PS1_FORMAT" "${BGPS_CHECKSUM}%( %s%) \$ "
    fi
  fi

  if (( "${#configs[@]}" )) ; then
    if [[ $OSTYPE == darwin* ]]; then  # OSX does not have md5sum binary by default
      hash_code="$(md5 -r "${configs[@]}" | awk '{print $1}' ORS="")"
    else
      hash_code="$(md5sum "${configs[@]}" | awk '{print $1}' ORS="")"
    fi
  fi

  if [[ -n "${hash_code}" ]] && [[ "${hash_code}" != "${BGPS_CHECKSUM}" ]] ; then
    BGPS_CHECKSUM="${hash_code}"
    _clear_config_values
    for config in "${configs[@]}" ; do
      _read_config "${config}"
    done
  fi

  return ${return_code}
}

#######################################
# Retrieve the list of valid bgps environment variables
#######################################
_bgps_globals() {
  local valid_globals=(
    "BGPS_CONFIG"
    "BGPS_GLOBAL_CONFIG"
    "BGPS_USER_CONFIG"
    "BGPS_CHECKSUM"
  )
  printf -- "%s " "${valid_globals[@]}"
}

#######################################
# Retrieve the list of valid keys for the environment variable $BGPS_CONFIG
#######################################
_bgps_config_keys() {
  local valid_config_keys=(
    "GIT_AHEAD"
    "GIT_BEHIND"
    "GIT_COLOR_CLEAN"
    "GIT_COLOR_CONFLICT"
    "GIT_COLOR_DIRTY"
    "GIT_COLOR_ENABLED"
    "GIT_COLOR_NO_UPSTREAM"
    "GIT_COLOR_UNTRACKED"
    "GIT_DIVERGED"
    "GIT_POSTFIX"
    "GIT_PREFIX"
    "GIT_BARE"
    "PS1_FORMAT"
    "TEXT_COLOR"
  )
  printf -- "%s " "${valid_config_keys[@]}"
}

_print_config_value() {
  local key="${1}"
  local value="${2}"
  printf -- "  %-*s = %s\n" 22 "${key}" "${value}"
}

#######################################
# Get current git branch and additional repository information
# Returns: 0 on success
#######################################
_branch_info() {
  local repo_info
  local rev_parse_exit_code

  repo_info="$(git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree --short HEAD 2>/dev/null)"
  rev_parse_exit_code="${?}"

  if [[ -z "${repo_info}" ]] ; then
    return 1
  fi

  local short_sha
  if (( !rev_parse_exit_code )) ; then
    short_sha="${repo_info##*$'\n'}"
    repo_info="${repo_info%$'\n'*}"
  fi

  repo_info="${repo_info%$'\n'*}"
  local bare_repo="${repo_info##*$'\n'}"
  repo_info="${repo_info%$'\n'*}"
  local inside_gitdir="${repo_info##*$'\n'}"
  local git_dir="${repo_info%$'\n'*}"

  local merge_status=""
  local branch=""
  local step=""
  local total=""
  if [[ -d "${git_dir}/rebase-merge" ]] ; then

    _eread "${git_dir}/rebase-merge/head-name" branch
    _eread "${git_dir}/rebase-merge/msgnum" step
    _eread "${git_dir}/rebase-merge/end" total

    if [[ -f "${git_dir}/rebase-merge/interactive" ]]; then
      merge_status="|REBASE-i"
    else
      merge_status="|REBASE-m"
    fi

  else

    if [[ -d "${git_dir}/rebase-apply" ]] ; then

      _eread "${git_dir}/rebase-apply/next" step
      _eread "${git_dir}/rebase-apply/last" total

      if [[ -f "${git_dir}/rebase-apply/rebasing" ]] ; then
        _eread "${git_dir}/rebase-apply/head-name" branch
        merge_status="|REBASE"
      elif [[ -f "${git_dir}/rebase-apply/applying" ]] ; then
        merge_status="|AM"
      else
        merge_status="|AM/REBASE"
      fi

    elif [[ -f "${git_dir}/MERGE_HEAD" ]] ; then
      merge_status="|MERGING"
    elif [[ -f "${git_dir}/CHERRY_PICK_HEAD" ]] ; then
      merge_status="|CHERRY-PICKING"
    elif [[ -f "${git_dir}/REVERT_HEAD" ]] ; then
      merge_status="|REVERTING"
    elif [[ -f "${git_dir}/BISECT_LOG" ]] ; then
      merge_status="|BISECTING"
    fi

    if [[ "${branch}" ]]; then
      :
    elif [[ -h "${git_dir}/HEAD" ]] ; then
      # symlink symbolic ref
      branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
      local head=""
      if ! _eread "${git_dir}/HEAD" head ; then
        return 1
      fi
      # is it a symbolic ref?
      branch="${head#ref: }"
      if [[ "${head}" == "${branch}" ]] ; then
        branch="$(git describe --tags --exact-match HEAD 2>/dev/null)" || branch="${short_sha}..."
        branch="(${branch})"
      fi
    fi
  fi

  if [[ -n "${step}" ]] && [[ -n "${total}" ]] ; then
    merge_status="${merge_status} ${step}/${total}"
  fi

  local prefix=""

  if [[ "${inside_gitdir}" == "true" ]] ; then
    if [[ "${bare_repo}" == "true" ]] ; then
      prefix="BARE:"
    else
      branch="GIT_DIR!"
    fi
  fi

  branch="${branch##refs/heads/}"

  printf -- "%s%s%s" "${prefix}" "${branch}" "${merge_status}"
  return 0
}

#######################################
# Get git status format
# Globals:
#   $stop_color
#   $BGPS_CONFIG
# Returns: 0 on success
#######################################
_bgps_git_status() {
  local color_enabled
  color_enabled="$(_get_config_value 'GIT_COLOR_ENABLED' 'false')"
  local color_clean
  color_clean="$(_get_config_value 'GIT_COLOR_CLEAN' '\[\033[2;92m\]')"
  local color_no_upstream
  color_no_upstream="$(_get_config_value 'GIT_COLOR_NO_UPSTREAM' '\[\033[2;40m\]')"
  local color_untracked
  color_untracked="$(_get_config_value 'GIT_COLOR_UNTRACKED' '\[\033[2;95m\]')"
  local color_dirty
  color_dirty="$(_get_config_value 'GIT_COLOR_DIRTY' '\[\033[2;91m\]')"
  local color_conflict
  color_conflict="$(_get_config_value 'GIT_COLOR_CONFLICT' '\[\033[0;33m\]')"
  local prefix
  prefix="$(_get_config_value 'GIT_PREFIX' '')"
  local postfix
  postfix="$(_get_config_value 'GIT_POSTFIX' '')"
  local git_ahead
  git_ahead="$(_get_config_value 'GIT_AHEAD' '[ahead %s]')"
  local git_behind
  git_behind="$(_get_config_value 'GIT_BEHIND' '[behind %s]')"
  local git_diverged
  git_diverged="$(_get_config_value 'GIT_DIVERGED' '[ahead %a] [behind %b]')"
  local git_bare
  git_bare="$(_get_config_value 'GIT_BARE' '')"
  local git_color="${stop_color}"
  local git_symbol=""

  local git_branch
  if ! git_branch="$(_branch_info)"; then
    return 1
  fi

  if [[ "$(git rev-parse --is-bare-repository)" == "true" ]]; then
    git_color="${color_no_upstream}"
    git_symbol="${git_bare}"
    if [[ ${color_enabled} == "true" ]] ; then
      printf -- "%s" "${git_color}"
    fi
    printf -- "%s%s%s%s" "${prefix:+${prefix}}" "${git_branch}" "${git_symbol:+ ${git_symbol}}" "${postfix:+${postfix}}"
    return 0
  fi

  local diff_error
  diff_error=$(git diff --no-ext-diff --quiet HEAD 2>&1)
  local dirty_exit_code="${?}" # code == 0 clean working tree, code == 1 dirty working tree

  # TODO: move logic to function
  # TODO: look in HEAD vs @{u} for bare repo vs normal repo. showing green after commit on bare repo should not
  local empty_git_error="ambiguous argument 'HEAD'"
  local no_upstream_git_error="no upstream configured"
  local no_such_branch_git_error="no such branch"
  local no_upstream=0
  if [[ "${diff_error}" == *"${empty_git_error}"* ]] || [[ "${diff_error}" == *"${no_upstream_git_error}"* ]] || [[ "${diff_error}" == *"${no_such_branch_git_error}"* ]]; then
    no_upstream=1
    # there is no upstream so compare against staging area
    diff_error=$(git diff --cached --no-ext-diff --quiet 2>&1)
    dirty_exit_code="${?}" # code == 0 clean working tree, code == 1 dirty working tree
  fi

  local untracked_exit_code="1" # code == 0 untracked files exist, code > 0 no untracked files
  # allow no upstream error to passthrough to apply coloring and formatting
  if (( "${dirty_exit_code}" == 0 )) || (( "${dirty_exit_code}" == 1 )) || (( "${no_upstream}" )); then
    
    git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null
    untracked_exit_code="${?}" # code == 0 untracked files exist, code > 0 no untracked files

    local commit_counts
    local commit_counts_exit_code
    if ((no_upstream)); then
      ahead_count="$(git rev-list --count HEAD 2>/dev/null)"
      commit_counts=("$ahead_count" 0)
      commit_counts_exit_code="${?}"
    else
      IFS=$'\t' read -r -a commit_counts <<< "$(git rev-list --left-right --count ...'@{u}' 2>/dev/null)"
      commit_counts_exit_code="${?}" # TODO: double check refactor on line above doesn't break this
    fi

    if ((!dirty_exit_code)) ; then
        git_color="${color_clean}"
    fi

    if ((commit_counts[0])) ; then
      git_color="${color_conflict}"
      git_symbol="${git_ahead/\%s/${commit_counts[0]}}"
    fi

    if ((commit_counts[1])) ; then
      git_color="${color_conflict}"
      git_symbol="${git_behind/\%s/${commit_counts[1]}}"
    fi

    if ((commit_counts[0] && commit_counts[1])) ; then
      git_symbol="${git_diverged/\%a/${commit_counts[0]}}"
      git_symbol="${git_symbol/\%b/${commit_counts[1]}}"
    fi

    # continue to check for untracked and dirty because
    # it is still possible even without an upstream

    if ((no_upstream)) || ((commit_counts_exit_code)) ; then
      # no upstream configured for branch
      git_color="${color_no_upstream}"
    fi

    if ((!untracked_exit_code)) ; then
        git_color="${color_untracked}"
        git_symbol="*${git_symbol#\*}"
    fi

    if (( dirty_exit_code == 1 )) && ((untracked_exit_code)) ; then
      git_color="${color_dirty}"
      git_symbol="*${git_symbol#\*}"
    fi

    if [[ ${color_enabled} == "true" ]] ; then
      printf -- "%s" "${git_color}"
    fi

    printf -- "%s%s%s%s" "${prefix:+${prefix}}" "${git_branch}" "${git_symbol:+ ${git_symbol}}" "${postfix:+${postfix}}"
  else
    if [[ ${color_enabled} == "true" ]] ; then
      printf -- "%s" "${color_dirty}"
    fi
    local state_dir="${HOME}/.local/state/bgps"
    local log_file="${state_dir}/log"
    mkdir -p "${state_dir}"
    printf -- "%s: %s\n" "$(date +%FT%T)" "${diff_error}" >> "${log_file}"
    printf -- "[bgps: error see %s for information]" "${log_file}"
  fi

  return 0
}

#######################################
# Set formatted git prompt
# Globals:
#   $stop_color
#   $BGPS_CONFIG
#######################################
_bgps_prompt() {
  local format
  format="$(_get_config_value 'PS1_FORMAT' "%(%s %)${stop_color}\$ ")"
  local text_color=
  text_color="$(_get_config_value 'TEXT_COLOR' "${stop_color}")"
  local status
  status="$(_bgps_git_status)"
  if [[ -z "${status}" ]] ; then
    format="${format/\%(*\%s*\%)/}"
    format="${format/\%BGPS_GIT_STATUS/}"
    PS1="${format}${text_color}"
  else
    local placeholder
    if [[ "${format}" =~ \%\(.*\%s.*\%\) ]] ; then
      placeholder="${BASH_REMATCH[0]#\%\(}"
      placeholder="${placeholder%\%\)}"
      format="${format/\%(*\%s*\%)/${placeholder}}"
    fi
    PS1="${format/\%BGPS_GIT_STATUS/${status}}${text_color}"
  fi
}

# Script Definition ###########################################################
# Globals:
#   $stop_color escape sequence to reset prompt color
#   $BGPS_CONFIG map of config values
#   $BGPS_CHECKSUM md5sum of config file

stop_color="\[\033[0m\]"
declare -A BGPS_CONFIG
BGPS_GLOBAL_CONFIG="${BGPS_GLOBAL_CONFIG-/etc/bgps_config}"
BGPS_USER_CONFIG="${BGPS_USER_CONFIG-${HOME}/.bgps_config}"

if _set_config "$@" ; then
  _bgps_prompt
fi

# unset variables and functions
unset stop_color
unset bgps_config_file
unset -f _err
unset -f _file_exists
unset -f _remove_quotes
unset -f _set_config_value
unset -f _get_config_value
unset -f _clear_config_values
unset -f _read_config
unset -f _set_config
unset -f _print_config
unset -f _bgps_git_status
unset -f _bgps_prompt
